Задача 3 Раскраска карты. Имеется географическая карта, на которой расположено n стран. Каждую страну надо раскрасить в один из k цветов так, чтобы соседние страны были раскрашены в разные цвета.



Географическую карту будем задавать в виде матрицы C размером nґ n. Элемент Ci,j равен 1, если страны i и j – соседние и равен 0 иначе.

Пространство перебора состоит из наборов (x1,...,xn), xi О {1, ...,k}. Условие совместимости m-го элемента с предыдущими: если Ci,m=1 (1 Ј i < m), то xi № xm.

Рекурсивная процедура, осуществляющая перебор с возвратом запишется по рассмотренной схеме:


  procedure перебор_с_возвратом(m : integer);
  var i : integer;
  begin
    if m > n  then
       <найдено решение>
    else
       for i := 1  to k  do begin
          цвет[m] := i;
          if <цвета стран 1,...,m-1 соседних с m-ой не i>  then
           перебор_с_возвратом(m+1);
          end;
  end;
Однако в отличие от задачи о ферзях, в данной задаче перебор можно сократить ещё больше за счёт симметрии решений задачи. Предположим, мы нашли решение задачи. Если мы теперь в этом решении у всех вершин поменяем местами i-ую и j-ую краску, то получившаяся раскраска тоже будет решением. Из таких симметричных решений нам достаточно найти одно. Таким образом, при выборе краски для очередной страны нам достаточно перебрать все уже используемые краски и всего одну (первую) из новых.


  procedure перебор_с_возвратом(m : integer);
  var i : integer;
  begin
     if m > n  then
        <найдено решение>
     else begin
         for i := 1  to кол_красок  do begin
            цвет[m] := i;
            if <цвета стран 1,...,m-1 соседних с m-ой не i>  then
                перебор_с_возвратом(m+1);
         end;
         if кол_красок < k  then begin
            кол_красок := кол_красок+1;
            цвет[m] := кол_красок;
            перебор_с_возвратом(m+1);
            кол_красок := кол_красок-1;
         end;
     end;
  end;